## 单例模式

**什么是单例模式**

单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。换句话来说，单例模式是在内存中仅会创建一次对象的设计模式。



**单例模式分类**

* **饿汉式**：类加载就会导致该单实例对象被创建。
* **懒汉式**：类加载不会导致该单实例对象被创建，而是首次使用该对象时被创建。



**饿汉式单例模式**

**相关代码**

```java
public class Main {
    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance();
        System.out.println(singleton);
    }
}


class  Singleton {
    private static Singleton instance = new Singleton();

    //构造方法私有化，也就是不能直接new Singleton()
    private Singleton() {

    }

    //得到实例的唯一途径
    public static Singleton getInstance() {
        return instance;
    }

}
```



**懒汉式单例模式**

**相关代码**

```java
public class Main {
    public static void main(String[] args) {
        Singleton singleton1 = Singleton.getInstance();
        System.out.println(singleton1);
    }
}

class Singleton {
    private static Singleton instance;
    private Singleton() {

    }

    public static Singleton getInstance() {
        if(instance==null){
            instance = new Singleton();
        }
        return instance;
    }
}
```



## 简单工厂模式

**什么是简单工厂模式**

通过一个工厂决定创建哪一种产品类型的实例。



**相关代码**

```java
public class Main {
    public static void main(String[] args) {
        Course course = SimpleFactory.createCourse("java");
        course.make();
    }
}

abstract class Course {
    public abstract void make();
}

class JavaCourse extends Course {
    public void make(){
        System.out.println("正在制作Java课程。");
    }
}

class PythonCourse extends Course {
    public void make(){
        System.out.println("正在制作Python课程。");
    }
}

class SimpleFactory {
    public static Course createCourse(String name) {
        if (name.equals("java")) {
            return new JavaCourse();
        } else if (name.equals("python")) {
            return new PythonCourse();
        }
        return null;
    }
}
```



## 工厂模式

**什么是工厂模式**

工厂模式是在简单模式的基础上，创建了一个工厂的抽象类。根据每个工厂不同的方法来产生不同所需要的对象。

**相关代码**

```java
public class Main {
    public static void main(String[] args) {
        CourseFactory javaFactory = new JavaFactory();
        CourseFactory pythonFactory = new PythonFactory();

        Course javaCourse = javaFactory.createCourse();
        Course pythonCourse = pythonFactory.createCourse();

        javaCourse.make();
        pythonCourse.make();
    }
}

abstract class Course {
    public abstract void make();
}

class JavaCourse extends Course {
    public void make(){
        System.out.println("正在制作Java课程。");
    }
}

class PythonCourse extends Course {
    public void make(){
        System.out.println("正在制作Python课程。");
    }
}

abstract class CourseFactory {

    public abstract Course createCourse();
}

class JavaFactory extends CourseFactory {

    @Override
    public Course createCourse() {
        return new JavaCourse();
    }
}

class PythonFactory extends CourseFactory {

    @Override
    public Course createCourse() {
        return new PythonCourse();
    }
}
```



## 抽象工厂模式

**什么是抽象工厂模式**

抽象工厂模式通俗的来说就是一家工厂生产多种零件。



**相关代码**

```java
public class Main {
    public static void main(String[] args) {
        CarFactory carFactory = new Car();
        carFactory.getCarDoor();
        carFactory.getBasePlate();
        carFactory.getFrame();
        carFactory.make();
    }
}

interface CarFactory {
    public void getCarDoor();
    public void getBasePlate();
    public void getFrame();
    public void make();
}

class Car implements CarFactory {
   public CarDoor carDoor = null;
    public BasePlate basePlate = null;
    public Frame frame = null;
    public void getCarDoor() {
        carDoor = new CarDoor();

    }
    public void getBasePlate() {
        basePlate = new BasePlate();
    }

    public void getFrame() {
        frame = new Frame();
    }

    public void make(){
        if(carDoor!=null&& basePlate!=null && frame!=null){
            carDoor.make();
            basePlate.make();
            frame.make();
        }
    }

}
class CarDoor extends CarDoorFactory {
    public void make() {
        System.out.println("CarDoor is made");
    }
}

class BasePlate extends BasePlateFactory {
    public void make() {
        System.out.println("BasePlate is made");
    }
}

class Frame extends FrameFactory {
    public void make() {
        System.out.println("Frame is made");
    }
}

abstract class CarDoorFactory {
    public abstract void make();
}

abstract class BasePlateFactory {
    public abstract void make();
}

abstract  class FrameFactory {
    public abstract void make();
}
```

